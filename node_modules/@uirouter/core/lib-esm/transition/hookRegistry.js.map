{
  "version": 3,
  "file": "hookRegistry.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/core/transition/hookRegistry.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\nimport { extend, removeFrom, tail, values, identity, map } from \"../common/common\";\nimport {isString, isFunction} from \"../common/predicates\";\nimport {PathNode} from \"../path/pathNode\";\nimport {\n    TransitionStateHookFn, TransitionHookFn, TransitionHookPhase, TransitionHookScope, IHookRegistry, PathType,\n} from \"./interface\"; // has or is using\n\nimport {\n    HookRegOptions, HookMatchCriteria, TreeChanges,\n    HookMatchCriterion, IMatchingNodes, HookFn,\n} from \"./interface\";\nimport {Glob} from \"../common/glob\";\nimport {StateObject} from \"../state/stateObject\";\nimport {TransitionEventType} from \"./transitionEventType\";\nimport { TransitionService } from \"./transitionService\";\n\n/**\n * Determines if the given state matches the matchCriteria\n *\n * @hidden\n *\n * @param state a State Object to test against\n * @param criterion\n * - If a string, matchState uses the string as a glob-matcher against the state name\n * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name\n *   and returns a positive match if any of the globs match.\n * - If a function, matchState calls the function with the state and returns true if the function's result is truthy.\n * @returns {boolean}\n */\nexport function matchState(state: StateObject, criterion: HookMatchCriterion) {\n  let toMatch = isString(criterion) ? [criterion] : criterion;\n\n  function matchGlobs(_state: StateObject) {\n    let globStrings = <string[]> toMatch;\n    for (let i = 0; i < globStrings.length; i++) {\n      let glob = new Glob(globStrings[i]);\n\n      if ((glob && glob.matches(_state.name)) || (!glob && globStrings[i] === _state.name)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  let matchFn = <any> (isFunction(toMatch) ? toMatch : matchGlobs);\n  return !!matchFn(state);\n}\n\n/**\n * @internalapi\n * The registration data for a registered transition hook\n */\nexport class RegisteredHook {\n  priority: number;\n  bind: any;\n  invokeCount = 0;\n  invokeLimit: number;\n  _deregistered = false;\n\n  constructor(public tranSvc: TransitionService,\n              public eventType: TransitionEventType,\n              public callback: HookFn,\n              public matchCriteria: HookMatchCriteria,\n              public removeHookFromRegistry: (hook: RegisteredHook) => void,\n              options: HookRegOptions = {} as any) {\n    this.priority = options.priority || 0;\n    this.bind = options.bind || null;\n    this.invokeLimit = options.invokeLimit;\n  }\n\n  /**\n   * Gets the matching [[PathNode]]s\n   *\n   * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing\n   * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.\n   *\n   * Returning `null` is significant to distinguish between the default\n   * \"match-all criterion value\" of `true` compared to a `() => true` function,\n   * when the nodes is an empty array.\n   *\n   * This is useful to allow a transition match criteria of `entering: true`\n   * to still match a transition, even when `entering === []`.  Contrast that\n   * with `entering: (state) => true` which only matches when a state is actually\n   * being entered.\n   */\n  private _matchingNodes(nodes: PathNode[], criterion: HookMatchCriterion): PathNode[] {\n    if (criterion === true) return nodes;\n    let matching = nodes.filter(node => matchState(node.state, criterion));\n    return matching.length ? matching : null;\n  }\n\n  /**\n   * Gets the default match criteria (all `true`)\n   *\n   * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:\n   *\n   * ```js\n   * {\n   *   to: true,\n   *   from: true,\n   *   entering: true,\n   *   exiting: true,\n   *   retained: true,\n   * }\n   */\n  private _getDefaultMatchCriteria(): HookMatchCriteria {\n    return map(this.tranSvc._pluginapi._getPathTypes(), () => true);\n  }\n\n  /**\n   * Gets matching nodes as [[IMatchingNodes]]\n   *\n   * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:\n   *\n   * ```js\n   * let matches: IMatchingNodes = {\n   *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),\n   *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),\n   *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),\n   *   retained: _matchingNodes(treeChanges.retained,     mc.retained),\n   *   entering: _matchingNodes(treeChanges.entering,     mc.entering),\n   * };\n   * ```\n   */\n  private _getMatchingNodes(treeChanges: TreeChanges): IMatchingNodes {\n    let criteria = extend(this._getDefaultMatchCriteria(), this.matchCriteria);\n    let paths: PathType[] = values(this.tranSvc._pluginapi._getPathTypes());\n\n    return paths.reduce((mn: IMatchingNodes, pathtype: PathType) => {\n      // STATE scope criteria matches against every node in the path.\n      // TRANSITION scope criteria matches against only the last node in the path\n      let isStateHook = pathtype.scope === TransitionHookScope.STATE;\n      let path = treeChanges[pathtype.name] || [];\n      let nodes: PathNode[] = isStateHook ? path : [tail(path)];\n\n      mn[pathtype.name] = this._matchingNodes(nodes, criteria[pathtype.name]);\n      return mn;\n    }, {} as IMatchingNodes);\n  }\n\n  /**\n   * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]\n   *\n   * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values\n   * are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)\n   */\n  matches(treeChanges: TreeChanges): IMatchingNodes {\n    let matches = this._getMatchingNodes(treeChanges);\n\n    // Check if all the criteria matched the TreeChanges object\n    let allMatched = values(matches).every(identity);\n    return allMatched ? matches : null;\n  }\n\n  deregister() {\n    this.removeHookFromRegistry(this);\n    this._deregistered = true;\n  }\n}\n\n/** @hidden Return a registration function of the requested type. */\nexport function makeEvent(registry: IHookRegistry, transitionService: TransitionService, eventType: TransitionEventType) {\n  // Create the object which holds the registered transition hooks.\n  const _registeredHooks = registry._registeredHooks = (registry._registeredHooks || {});\n  const hooks = _registeredHooks[eventType.name] = [];\n  const removeHookFn: (hook: RegisteredHook) => void = removeFrom(hooks);\n\n  // Create hook registration function on the IHookRegistry for the event\n  registry[eventType.name] = hookRegistrationFn;\n\n  function hookRegistrationFn(matchObject, callback, options = {}) {\n    const registeredHook = new RegisteredHook(transitionService, eventType, callback, matchObject, removeHookFn, options);\n    hooks.push(registeredHook);\n    return registeredHook.deregister.bind(registeredHook);\n  }\n\n  return hookRegistrationFn;\n}\n"
  ]
}