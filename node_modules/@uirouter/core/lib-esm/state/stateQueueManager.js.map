{
  "version": 3,
  "file": "stateQueueManager.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/core/state/stateQueueManager.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "/** @module state */ /** for typedoc */\nimport { inArray } from \"../common/common\";\nimport { isString } from \"../common/predicates\";\nimport { StateDeclaration, _StateDeclaration } from \"./interface\";\nimport { StateObject } from \"./stateObject\";\nimport { StateBuilder } from \"./stateBuilder\";\nimport { StateRegistryListener, StateRegistry } from \"./stateRegistry\";\nimport { Disposable } from \"../interface\";\nimport { UrlRouter } from \"../url/urlRouter\";\nimport { prop } from \"../common/hof\";\nimport { StateMatcher } from \"./stateMatcher\";\n\n/** @internalapi */\nexport class StateQueueManager implements Disposable {\n  queue: StateObject[];\n  matcher: StateMatcher;\n\n  constructor(\n      private $registry: StateRegistry,\n      private $urlRouter: UrlRouter,\n      public states: { [key: string]: StateObject; },\n      public builder: StateBuilder,\n      public listeners: StateRegistryListener[]) {\n    this.queue = [];\n    this.matcher = $registry.matcher;\n  }\n\n  /** @internalapi */\n  dispose() {\n    this.queue = [];\n  }\n\n  register(stateDecl: _StateDeclaration) {\n    let queue = this.queue;\n    let state = StateObject.create(stateDecl);\n    let name = state.name;\n\n    if (!isString(name)) throw new Error(\"State must have a valid name\");\n    if (this.states.hasOwnProperty(name) || inArray(queue.map(prop('name')), name))\n      throw new Error(`State '${name}' is already defined`);\n\n    queue.push(state);\n    this.flush();\n\n    return state;\n  }\n\n  flush() {\n    let {queue, states, builder} = this;\n    let registered: StateObject[] = [], // states that got registered\n        orphans: StateObject[] = [], // states that don't yet have a parent registered\n        previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered\n    const getState = (name) =>\n        this.states.hasOwnProperty(name) && this.states[name];\n\n    while (queue.length > 0) {\n      let state: StateObject = queue.shift();\n      let name = state.name;\n      let result: StateObject = builder.build(state);\n      let orphanIdx: number = orphans.indexOf(state);\n\n      if (result) {\n        let existingState = getState(name);\n        if (existingState && existingState.name === name) {\n          throw new Error(`State '${name}' is already defined`);\n        }\n\n        let existingFutureState = getState(name + \".**\");\n        if (existingFutureState) {\n          // Remove future state of the same name\n          this.$registry.deregister(existingFutureState);\n        }\n\n        states[name] = state;\n        this.attachRoute(state);\n        if (orphanIdx >= 0) orphans.splice(orphanIdx, 1);\n        registered.push(state);\n        continue;\n      }\n\n      let prev = previousQueueLength[name];\n      previousQueueLength[name] = queue.length;\n      if (orphanIdx >= 0 && prev === queue.length) {\n        // Wait until two consecutive iterations where no additional states were dequeued successfully.\n        // throw new Error(`Cannot register orphaned state '${name}'`);\n        queue.push(state);\n        return states;\n      } else if (orphanIdx < 0) {\n        orphans.push(state);\n      }\n\n      queue.push(state);\n    }\n\n    if (registered.length) {\n      this.listeners.forEach(listener => listener(\"registered\", registered.map(s => s.self)));\n    }\n\n    return states;\n  }\n\n  attachRoute(state: StateObject) {\n    if (state.abstract || !state.url) return;\n\n    this.$urlRouter.rule(this.$urlRouter.urlRuleFactory.create(state));\n  }\n}\n"
  ]
}