{
  "version": 3,
  "file": "injector.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/core/vanilla/injector.ts"
  ],
  "names": [],
  "mappings": "AAAA;;;GAGG;AACH,MAAM;AACN,OAAO,EACL,MAAM,EAAE,eAAe,EAAE,UAAU,EAAE,OAAO,EAAE,YAAY,EAC3D,MAAM,iBAAiB,CAAC;AAEzB,iCAAiC;AACjC,IAAI,OAAO,GAAG,EAAE,CAAC;AACjB,IAAI,cAAc,GAAG,kCAAkC,CAAC;AACxD,IAAI,cAAc,GAAG,YAAY,CAAC;AAElC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA8CG;AACH,MAAM,CAAC,IAAM,SAAS,GAAG;IACvB,qDAAqD;IACrD,GAAG,EAAE,UAAA,IAAI,IAAI,OAAA,OAAO,CAAC,IAAI,CAAC,EAAb,CAAa;IAE1B,iEAAiE;IACjE,GAAG,EAAE,UAAC,IAAI,IAAK,OAAA,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,IAAI,EAA3B,CAA2B;IAE1C;;;;;;OAMG;IACH,MAAM,EAAE,UAAC,EAAe,EAAE,OAAQ,EAAE,MAAO;QACzC,IAAI,GAAG,GAAG,MAAM,CAAC,EAAE,EAAE,OAAO,EAAE,MAAM,IAAI,EAAE,CAAC,CAAC;QAC5C,IAAI,MAAM,GAAG,SAAS,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;QACpC,IAAI,WAAW,GAAG,eAAe,CAAC,UAAC,GAAW,IAAK,OAAA,GAAG,CAAC,cAAc,CAAC,GAAG,CAAC,EAAvB,CAAuB,EAAE,UAAA,GAAG,IAAI,OAAA,gCAA8B,GAAG,MAAG,EAApC,CAAoC,CAAC,CAAC;QACzH,IAAI,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC,GAAG,CAAC,UAAA,CAAC,IAAI,OAAA,GAAG,CAAC,CAAC,CAAC,EAAN,CAAM,CAAC,CAAC;QACvD,EAAE,CAAC,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;YAAC,MAAM,CAAC,EAAE,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QACnD,IAAI;YAAC,MAAM,CAAE,EAAY,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;IAC9D,CAAC;IAED;;;;;OAKG;IACH,QAAQ,EAAE,UAAC,EAAe;QACxB,EAAE,CAAC,CAAC,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC;YAAC,MAAM,IAAI,KAAK,CAAC,iCAA+B,EAAI,CAAC,CAAC;QAC5E,EAAE,CAAC,CAAC,EAAE,IAAK,EAAU,CAAC,OAAO,CAAC;YAAC,MAAM,CAAE,EAAU,CAAC,OAAO,CAAC;QAC1D,EAAE,CAAC,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;YAAC,MAAM,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QACxC,IAAI,KAAK,GAAG,EAAE,CAAC,QAAQ,EAAE,CAAC,OAAO,CAAC,cAAc,EAAE,EAAE,CAAC,CAAC;QACtD,IAAI,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC;QAC3F,MAAM,CAAC,MAAM,IAAI,EAAE,CAAC;IACtB,CAAC;CACe,CAAC",
  "sourcesContent": [
    "/**\n * @internalapi\n * @module vanilla\n */\n/** */\nimport {\n  extend, assertPredicate, isFunction, isArray, isInjectable, $InjectorLike, IInjectable\n} from \"../common/index\";\n\n// globally available injectables\nlet globals = {};\nlet STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\nlet ARGUMENT_NAMES = /([^\\s,]+)/g;\n\n/**\n * A basic angular1-like injector api\n *\n * This object implements four methods similar to the\n * [angular 1 dependency injector](https://docs.angularjs.org/api/auto/service/$injector)\n *\n * UI-Router evolved from an angular 1 library to a framework agnostic library.\n * However, some of the `@uirouter/core` code uses these ng1 style APIs to support ng1 style dependency injection.\n *\n * This object provides a naive implementation of a globally scoped dependency injection system.\n * It supports the following DI approaches:\n *\n * ### Function parameter names\n *\n * A function's `.toString()` is called, and the parameter names are parsed.\n * This only works when the parameter names aren't \"mangled\" by a minifier such as UglifyJS.\n *\n * ```js\n * function injectedFunction(FooService, BarService) {\n *   // FooService and BarService are injected\n * }\n * ```\n *\n * ### Function annotation\n *\n * A function may be annotated with an array of dependency names as the `$inject` property.\n *\n * ```js\n * injectedFunction.$inject = [ 'FooService', 'BarService' ];\n * function injectedFunction(fs, bs) {\n *   // FooService and BarService are injected as fs and bs parameters\n * }\n * ```\n *\n * ### Array notation\n *\n * An array provides the names of the dependencies to inject (as strings).\n * The function is the last element of the array.\n *\n * ```js\n * [ 'FooService', 'BarService', function (fs, bs) {\n *   // FooService and BarService are injected as fs and bs parameters\n * }]\n * ```\n *\n * @type {$InjectorLike}\n */\nexport const $injector = {\n  /** Gets an object from DI based on a string token */\n  get: name => globals[name],\n\n  /** Returns true if an object named `name` exists in global DI */\n  has: (name) => $injector.get(name) != null,\n\n  /**\n   * Injects a function\n   *\n   * @param fn the function to inject\n   * @param context the function's `this` binding\n   * @param locals An object with additional DI tokens and values, such as `{ someToken: { foo: 1 } }`\n   */\n  invoke: (fn: IInjectable, context?, locals?) => {\n    let all = extend({}, globals, locals || {});\n    let params = $injector.annotate(fn);\n    let ensureExist = assertPredicate((key: string) => all.hasOwnProperty(key), key => `DI can't find injectable: '${key}'`);\n    let args = params.filter(ensureExist).map(x => all[x]);\n    if (isFunction(fn)) return fn.apply(context, args);\n    else return (fn as any[]).slice(-1)[0].apply(context, args);\n  },\n\n  /**\n   * Returns a function's dependencies\n   *\n   * Analyzes a function (or array) and returns an array of DI tokens that the function requires.\n   * @return an array of `string`s\n   */\n  annotate: (fn: IInjectable): any[] => {\n    if (!isInjectable(fn)) throw new Error(`Not an injectable function: ${fn}`);\n    if (fn && (fn as any).$inject) return (fn as any).$inject;\n    if (isArray(fn)) return fn.slice(0, -1);\n    let fnStr = fn.toString().replace(STRIP_COMMENTS, '');\n    let result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\n    return result || [];\n  }\n} as $InjectorLike;"
  ]
}