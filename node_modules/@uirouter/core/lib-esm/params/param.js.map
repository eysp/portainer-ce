{
  "version": 3,
  "file": "param.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/core/params/param.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "/**\n * @coreapi\n * @module params\n */ /** for typedoc */\nimport { extend, filter, map, allTrueR } from \"../common/common\";\nimport { prop } from \"../common/hof\";\nimport { isInjectable, isDefined, isString, isArray, isUndefined } from \"../common/predicates\";\nimport { RawParams, ParamDeclaration } from \"../params/interface\";\nimport { services } from \"../common/coreservices\";\nimport { ParamType } from \"./paramType\";\nimport { ParamTypes } from \"./paramTypes\";\nimport { UrlMatcherFactory } from \"../url/urlMatcherFactory\";\n\n/** @hidden */ let hasOwn = Object.prototype.hasOwnProperty;\n/** @hidden */ let isShorthand = (cfg: ParamDeclaration) =>\n    [\"value\", \"type\", \"squash\", \"array\", \"dynamic\"].filter(hasOwn.bind(cfg || {})).length === 0;\n\n/** @internalapi */\nexport enum DefType {\n  PATH,\n  SEARCH,\n  CONFIG,\n}\n\n/** @hidden */\nfunction unwrapShorthand(cfg: ParamDeclaration): ParamDeclaration {\n  cfg = isShorthand(cfg) && { value: cfg } as any || cfg;\n\n  getStaticDefaultValue['__cacheable'] = true;\n  function getStaticDefaultValue() {\n    return cfg.value;\n  }\n\n  return extend(cfg, {\n    $$fn: isInjectable(cfg.value) ? cfg.value : getStaticDefaultValue,\n  });\n}\n\n/** @hidden */\nfunction getType(cfg: ParamDeclaration, urlType: ParamType, location: DefType, id: string, paramTypes: ParamTypes) {\n  if (cfg.type && urlType && urlType.name !== 'string') throw new Error(`Param '${id}' has two type configurations.`);\n  if (cfg.type && urlType && urlType.name === 'string' && paramTypes.type(cfg.type as string)) return paramTypes.type(cfg.type as string);\n  if (urlType) return urlType;\n  if (!cfg.type) {\n    let type = location === DefType.CONFIG ? \"any\" :\n        location === DefType.PATH ? \"path\" :\n        location === DefType.SEARCH ? \"query\" : \"string\";\n    return paramTypes.type(type);\n  }\n  return cfg.type instanceof ParamType ? cfg.type : paramTypes.type(cfg.type as string);\n}\n\n/**\n * @internalapi\n * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n */\nfunction getSquashPolicy(config: ParamDeclaration, isOptional: boolean, defaultPolicy: (boolean|string)) {\n  let squash = config.squash;\n  if (!isOptional || squash === false) return false;\n  if (!isDefined(squash) || squash == null) return defaultPolicy;\n  if (squash === true || isString(squash)) return squash;\n  throw new Error(`Invalid squash policy: '${squash}'. Valid policies: false, true, or arbitrary string`);\n}\n\n/** @internalapi */\nfunction getReplace(config: ParamDeclaration, arrayMode: boolean, isOptional: boolean, squash: (string|boolean)) {\n  let replace: any, configuredKeys: string[], defaultPolicy = [\n    {from: \"\", to: (isOptional || arrayMode ? undefined : \"\")},\n    {from: null, to: (isOptional || arrayMode ? undefined : \"\")},\n  ];\n  replace = isArray(config.replace) ? config.replace : [];\n  if (isString(squash)) replace.push({ from: squash, to: undefined });\n  configuredKeys = map(replace, prop(\"from\"));\n  return filter(defaultPolicy, item => configuredKeys.indexOf(item.from) === -1).concat(replace);\n}\n\n\n/** @internalapi */\nexport class Param {\n  id: string;\n  type: ParamType;\n  location: DefType;\n  isOptional: boolean;\n  dynamic: boolean;\n  raw: boolean;\n  squash: (boolean|string);\n  replace: [{ to: any, from: any }];\n  inherit: boolean;\n  array: boolean;\n  config: any;\n  /** Cache the default value if it is a static value */\n  _defaultValueCache: {\n    defaultValue: any,\n  };\n\n  constructor(id: string, type: ParamType, config: ParamDeclaration, location: DefType, urlMatcherFactory: UrlMatcherFactory) {\n    config = unwrapShorthand(config);\n    type = getType(config, type, location, id, urlMatcherFactory.paramTypes);\n    let arrayMode = getArrayMode();\n    type = arrayMode ? type.$asArray(arrayMode, location === DefType.SEARCH) : type;\n    let isOptional = config.value !== undefined || location === DefType.SEARCH;\n    let dynamic = isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic;\n    let raw = isDefined(config.raw) ? !!config.raw : !!type.raw;\n    let squash = getSquashPolicy(config, isOptional, urlMatcherFactory.defaultSquashPolicy());\n    let replace = getReplace(config, arrayMode, isOptional, squash);\n    let inherit = isDefined(config.inherit) ? !!config.inherit : !!type.inherit;\n\n    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n    function getArrayMode() {\n      let arrayDefaults = { array: (location === DefType.SEARCH ? \"auto\" : false) };\n      let arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n    }\n\n    extend(this, {id, type, location, isOptional, dynamic, raw, squash, replace, inherit, array: arrayMode, config });\n  }\n\n  isDefaultValue(value: any): boolean {\n    return this.isOptional && this.type.equals(this.value(), value);\n  }\n\n  /**\n   * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n   * default value, which may be the result of an injectable function.\n   */\n  value(value?: any): any {\n    /**\n     * [Internal] Get the default value of a parameter, which may be an injectable function.\n     */\n    const getDefaultValue = () => {\n      if (this._defaultValueCache) return this._defaultValueCache.defaultValue;\n\n      if (!services.$injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n\n      let defaultValue = services.$injector.invoke(this.config.$$fn);\n\n      if (defaultValue !== null && defaultValue !== undefined && !this.type.is(defaultValue))\n        throw new Error(`Default value (${defaultValue}) for parameter '${this.id}' is not an instance of ParamType (${this.type.name})`);\n\n      if (this.config.$$fn['__cacheable']) {\n        this._defaultValueCache = { defaultValue };\n      }\n\n      return defaultValue;\n    };\n\n    const replaceSpecialValues = (val: any) => {\n      for (let tuple of this.replace) {\n        if (tuple.from === val) return tuple.to;\n      }\n      return val;\n    };\n\n    value = replaceSpecialValues(value);\n\n    return isUndefined(value) ? getDefaultValue() : this.type.$normalize(value);\n  }\n\n  isSearch(): boolean {\n    return this.location === DefType.SEARCH;\n  }\n\n  validates(value: any): boolean {\n    // There was no parameter value, but the param is optional\n    if ((isUndefined(value) || value === null) && this.isOptional) return true;\n\n    // The value was not of the correct ParamType, and could not be decoded to the correct ParamType\n    const normalized = this.type.$normalize(value);\n    if (!this.type.is(normalized)) return false;\n\n    // The value was of the correct type, but when encoded, did not match the ParamType's regexp\n    const encoded = this.type.encode(normalized);\n    return !(isString(encoded) && !this.type.pattern.exec(<string> encoded));\n  }\n\n  toString() {\n    return `{Param:${this.id} ${this.type} squash: '${this.squash}' optional: ${this.isOptional}}`;\n  }\n\n  static values(params: Param[], values: RawParams = {}): RawParams {\n    const paramValues = {} as RawParams;\n    for (let param of params) {\n      paramValues[param.id] = param.value(values[param.id]);\n    }\n    return paramValues;\n  }\n\n  /**\n   * Finds [[Param]] objects which have different param values\n   *\n   * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects\n   *\n   * @param params: The list of Param objects to filter\n   * @param values1: The first set of parameter values\n   * @param values2: the second set of parameter values\n   *\n   * @returns any Param objects whose values were different between values1 and values2\n   */\n  static changed(params: Param[], values1: RawParams = {}, values2: RawParams = {}): Param[] {\n    return params.filter(param => !param.type.equals(values1[param.id], values2[param.id]));\n  }\n\n  /**\n   * Checks if two param value objects are equal (for a set of [[Param]] objects)\n   *\n   * @param params The list of [[Param]] objects to check\n   * @param values1 The first set of param values\n   * @param values2 The second set of param values\n   *\n   * @returns true if the param values in values1 and values2 are equal\n   */\n  static equals(params: Param[], values1 = {}, values2 = {}): boolean {\n    return Param.changed(params, values1, values2).length === 0;\n  }\n\n  /** Returns true if a the parameter values are valid, according to the Param definitions */\n  static validates(params: Param[], values: RawParams = {}): boolean {\n    return params.map(param => param.validates(values[param.id])).reduce(allTrueR, true);\n  }\n}"
  ]
}